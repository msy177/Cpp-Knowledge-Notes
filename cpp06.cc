/*


类


*/

// class A{

// };//一定加分号


// 类内函数声明定义尽量分离


//访问限定符 public protected private

//类里只存储成员变量 不存储成员函数 -》大小

//每个示例化的类对象 如果都放成员函数 浪费空间，所以都放在代码段 只存储成员变量
//相当于都有各自的成员变量 共享成员函数


// 类未实例化时，类本身不占用堆 / 栈 / 全局数据区的空间（类只是 “模板”，不是具体对象）；
// 但类的静态成员变量（若有）会占用空间（全局数据区），与是否实例化无关；

// 类的所有成员函数（普通、静态、虚函数）都会存入代码段（只读内存区），
// 无论类是否实例化 —— 成员函数是 “共享代码”，所有实例共用同一套，不会为每个实例重复存储。\




// 定义类（仅图纸，未实例化）
// class TestClass {
// public:
    // int a;          // 普通成员变量（实例级，仅实例化后分配空间）
    // static int b;   // 静态成员变量（类级，全局唯一）
    // void func() {}  // 普通成员函数（共享代码，存代码段）
// };

// 静态成员变量初始化（类级资源，无论是否实例化，都会占用全局数据区空间）
// int TestClass::b = 10;

// 用 sizeof(TestClass) 可以查看 “实例对象的大小”，但这不是 “类本身的大小”：
// cpp
// 未实例化任何 TestClass 对象
// cout << sizeof(TestClass) << endl;  // 输出 4（仅普通成员变量a的大小，不含静态成员b）
// sizeof(TestClass) 计算的是「实例对象的内存大小」（仅包含普通成员变量、虚表指针 vptr，不含静态成员、成员函数）；
// 哪怕未实例化，sizeof(TestClass) 也会返回实例大小（编译期确定），但这并不代表类本身占用了内存 —— 只是编译器提前计算出 “按图纸建房需要多大空间”。

// 所有成员函数（普通、静态、虚函数）的本质是「可执行代码」，编译后都会存入 代码段（.text 段）—— 代码段是只读内存区，存储所有可执行指令，与类是否实例化无关。
// 1. 普通成员函数（非静态、非虚）
// 存储位置：代码段；
// 特点：所有实例共用同一套代码，不会为每个实例重复存储；
// 调用逻辑：实例调用 obj.func() 时，编译器会隐式传入 this 指针（指向当前实例），函数通过 this 访问实例的普通成员变量（如 this->a）。
// 2. 静态成员函数（static）
// 存储位置：代码段；
// 特点：
// 与普通成员函数一样，存代码段，未实例化也存在；
// 无 this 指针，不能访问普通成员变量（只能访问静态成员变量）；
// 可直接通过类调用（TestClass::static_func()），无需实例化。
// 3. 虚函数（virtual）
// 存储位置：代码段（函数体本身）+ 全局数据区（虚函数表 vtable）；
// 特点：
// 虚函数体存代码段，与是否实例化无关；
// 类有虚函数时，编译器会生成一个「虚函数表（vtable）」（全局数据区，仅一份，与实例无关），存储所有虚函数的地址；
// 实例化后，每个对象会多一个「虚表指针（vptr）」（8 字节 / 64 位），指向 vtable—— 这是实例的内存开销，不是类的开销。


// #include <iostream>

// class A{

// };
// class B{
//     void fun();
// };
// int main(){
//     A a;
//     std::cout<<sizeof(A)<<std::endl;
//     std::cout<<sizeof(B)<<std::endl;
//     std::cout<<sizeof(a)<<std::endl;
// }

// msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ ./test 
// 1
// 1
// 1
// msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ 

//成员函数不占内存 空类大小为1  占一个坑
//C++标准强制规定的，保证每个对象都有唯一的内存地址 &取地址的时候能取到地址

// 1. 保证 “对象唯一性”：避免两个对象地址相同
// C++ 的核心规则之一是：不同的对象必须有不同的内存地址。如果空类占 0 字节：
// 实例化多个空类对象时，它们会 “重叠” 在同一块内存（地址相同）；
// 导致 &a == &b，指针 Empty* p1 = &a; Empty* p2 = &b; 无法区分两个对象；
// 进一步破坏 “指针指向唯一对象” 的语义，比如 p1 == p2 会返回 true，但它们本应指向不同对象。
// 这就像 “两个空盒子不能放在同一个位置”—— 哪怕盒子里没东西，也得占个地方，不然分不清哪个是哪个。
// 2. 支持 “对象的存储与管理”：兼容容器、数组等特性
// C++ 的容器（如 vector、list）、数组都要求 “元素是可寻址的实体”，如果空类占 0 字节：
// 数组 Empty arr[2] 中，arr[0] 和 arr[1] 地址相同，数组失去意义（无法通过索引区分元素）；
// 容器 vector<Empty> 无法存储多个元素（所有元素重叠在同一地址）；
// 甚至无法通过指针 / 引用操作对象（地址相同导致操作混淆）。
// 1 字节的占位，让空类对象能像普通对象一样被存储、索引、传递，兼容 C++ 的所有数据结构。
// 3. 维持 “类与对象的语义一致性”：空类也是 “类”，实例也是 “对象”
// 类的本质是 “创建对象的模板”，对象的本质是 “内存中的实体”—— 哪怕模板是空的，创建出的实体也必须是 “有位置的”。如果空类占 0 字节：
// 空类的实例就不是 “真正的对象”（没有内存实体），违背了 “类→实例” 的语义；
// 导致 sizeof(Empty) == 0，而 C++ 标准明确规定：任何对象的大小都不能为 0（sizeof(obj) ≥ 1）。
// 1 字节是 “最小的内存单位”（大多数系统中），既满足 “对象有内存实体” 的要求，又不会造成额外的内存浪费（1 字节代价可忽略）。



// class Empty {};  // 空类，sizeof(Empty) = 1
// class Derived : public Empty {  // 继承空基类
//     int x;  // 子类有一个int成员（4字节）
// };

// int main() {
//     cout << sizeof(Derived) << endl;  // 输出4（不是1+4=5）
//     return 0;
// }



///////////////////////////////////////////////////////////////////////////////

#include <iostream>

class A{
    char c;
};
class B{
    char c;
    int a;
};
class C{
    int a;
    char c;
};
class D{
    char c1;
    char c2;
    char c3;
    int a;
};
class E{
    char c1;
    char c2;
    char c3;
    int a;
    char c;
};
int main(){
    A a;
    std::cout<<sizeof(a)<<std::endl;
    B b;
    std::cout<<sizeof(b)<<std::endl;
    C c;
    std::cout<<sizeof(c)<<std::endl;
    D d;
    std::cout<<sizeof(d)<<std::endl;
    E e;
    std::cout<<sizeof(e)<<std::endl;
}
// .msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ ./test 
// 1
// 8
// 8
// 8
// 12
// msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ 
//内存对齐 所以先放char 再放int 是节省空间的


// 腾讯服务器默认禁用 ICMP 响应（即 ping 命令的底层协议），因此直接执行 ping qq.com 或 ping 101.226.103.105 可能超时或返回错误。














