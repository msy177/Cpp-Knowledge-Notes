
//引用


// #include <iostream>
// int main(){
//     int a = 1;
//     int &ra = a;//ra是a的引用，引用也就是别名，a再取了一个名称
//     a = 2;
//     ra = 3;
//     std::cout<<a<<std::endl;
// }


// Dump of assembler code for function main():
//    0x00000000000011c9 <+0>:     endbr64 
//    0x00000000000011cd <+4>:     push   %rbp
//    0x00000000000011ce <+5>:     mov    %rsp,%rbp
//    0x00000000000011d1 <+8>:     sub    $0x20,%rsp
//    0x00000000000011d5 <+12>:    mov    %fs:0x28,%rax
//    0x00000000000011de <+21>:    mov    %rax,-0x8(%rbp)
//    0x00000000000011e2 <+25>:    xor    %eax,%eax
//    0x00000000000011e4 <+27>:    movl   $0x1,-0x14(%rbp) //把1放入寄存器中
//    0x00000000000011eb <+34>:    lea    -0x14(%rbp),%rax //寄存器的
//    0x00000000000011ef <+38>:    mov    %rax,-0x10(%rbp)
//    0x00000000000011f3 <+42>:    movl   $0x2,-0x14(%rbp)
//    0x00000000000011fa <+49>:    mov    -0x10(%rbp),%rax
// --Type <RET> for more, q to quit, c to continue without paging--
// 汇编的源码






////////下面是 -O0优化级别 也就是无优化的 再看下02的
//    int main(){
//    0x00000000000011c9 <+0>:     endbr64 
//    0x00000000000011cd <+4>:     push   %rbp
//    0x00000000000011ce <+5>:     mov    %rsp,%rbp
//    0x00000000000011d1 <+8>:     sub    $0x20,%rsp
//    0x00000000000011d5 <+12>:    mov    %fs:0x28,%rax
//    0x00000000000011de <+21>:    mov    %rax,-0x8(%rbp)
//    0x00000000000011e2 <+25>:    xor    %eax,%eax

// 6           int a = 1;
//    0x00000000000011e4 <+27>:    movl   $0x1,-0x14(%rbp)

// 7           int &ra = a;//ra是a的引用，引用也就是别名，a再取了一个名称
//    0x00000000000011eb <+34>:    lea    -0x14(%rbp),%rax
//    0x00000000000011ef <+38>:    mov    %rax,-0x10(%rbp)

// 8           a = 2;
//    0x00000000000011f3 <+42>:    movl   $0x2,-0x14(%rbp)

// 9           ra = 3;
//    0x00000000000011fa <+49>:    mov    -0x10(%rbp),%rax
//    0x00000000000011fe <+53>:    movl   $0x3,(%rax)

// --Type <RET> for more, q to quit, c to continue without paging--ret
// 10          std::cout<<a<<std::endl;
//    0x0000000000001204 <+59>:    mov    -0x14(%rbp),%eax
//    0x0000000000001207 <+62>:    mov    %eax,%esi
//    0x0000000000001209 <+64>:    lea    0x2e30(%rip),%rax        # 0x4040 <_ZSt4cout@GLIBCXX_3.4>
//    0x0000000000001210 <+71>:    mov    %rax,%rdi
//    0x0000000000001213 <+74>:    call   0x10d0 <_ZNSolsEi@plt>
//    0x0000000000001218 <+79>:    mov    0x2db1(%rip),%rdx        # 0x3fd0
//    0x000000000000121f <+86>:    mov    %rdx,%rsi
//    0x0000000000001222 <+89>:    mov    %rax,%rdi
//    0x0000000000001225 <+92>:    call   0x10a0 <_ZNSolsEPFRSoS_E@plt>

// 11      }
//    0x000000000000122a <+97>:    mov    $0x0,%eax
//    0x000000000000122f <+102>:   mov    -0x8(%rbp),%rdx
//    0x0000000000001233 <+106>:   sub    %fs:0x28,%rdx
//    0x000000000000123c <+115>:   je     0x1243 <main()+122>
//    0x000000000000123e <+117>:   call   0x10b0 <__stack_chk_fail@plt>
//    0x0000000000001243 <+122>:   leave  
//    0x0000000000001244 <+123>:   ret    



///////下面是O2优化级别
// (gdb) disassemble /m main
// Dump of assembler code for function main():
// 5       int main(){
//    0x0000000000001120 <+0>:     endbr64 
//    0x0000000000001124 <+4>:     push   %r12
//    0x0000000000001132 <+18>:    push   %rbp
//    0x0000000000001133 <+19>:    sub    $0x8,%rsp

// 6           int a = 1;

// 7           int &ra = a;//ra是a的引用，引用也就是别名，a再取了一个名称

// 8           a = 2;

// 9           ra = 3;

// 10          std::cout<<a<<std::endl;
//    0x0000000000001126 <+6>:     mov    $0x3,%esi
//    0x000000000000112b <+11>:    lea    0x2f0e(%rip),%rdi        # 0x4040 <_ZSt4cout@GLIBCXX_3.4>
//    0x0000000000001137 <+23>:    call   0x1110 <_ZNSolsEi@plt>
//    0x000000000000113c <+28>:    mov    %rax,%rbp

// 11      }
//    0x0000000000001171 <+81>:    add    $0x8,%rsp
//    0x0000000000001175 <+85>:    xor    %eax,%eax
//    0x0000000000001177 <+87>:    pop    %rbp



//在无优化的级别下，引用底层起始就占用了内存空间，存了原变量的地址，操作就是操作原变量的地址 相当于一个指针变量 存了一个地址

//在02优化级别下 由于常量传播+死代码消除+变量内联 直接跳过了一些步骤，直接把3传入a里面
//这是因为编译器推断出了，所以编译的时候直接优化了，但是不代表引用不占空间，如果编译器无法自动识别推断就不行了

// O2 优化的核心逻辑（为什么看不到 ra 的内存）：
// 编译器做了 3 层关键优化，彻底消除了引用的内存占用：
// 常量传播：推导a的取值链 1→2→3，直接得出最终值是 3，无需逐次执行赋值；
// 死代码消除：因为a的最终值可编译期确定，存储a的栈空间、存储ra地址的栈空间都成了 “无用代码”，被直接删除；
// 变量内联：把a的最终值 3 直接传入cout的参数寄存器（esi），跳过 “栈存储变量→取变量值→传参” 的步骤




// 我们看看编译器自动推断不了情况

// 修改后的代码（a的值不可编译期确定）
#include <iostream>
const int j = 1;
int main() {
    const int c = 10;
    int a;
    std::cin >> a; // 运行时输入，编译器无法推导值
    int &ra = a;
    ra = 3;
    std::cout << a << std::endl;
}
// Dump of assembler code for function main():
// 131     int main() {
//    0x00000000000011e9 <+0>:     endbr64 
//    0x00000000000011ed <+4>:     push   %rbp
//    0x00000000000011ee <+5>:     mov    %rsp,%rbp
//    0x00000000000011f1 <+8>:     sub    $0x20,%rsp
//    0x00000000000011f5 <+12>:    mov    %fs:0x28,%rax
//    0x00000000000011fe <+21>:    mov    %rax,-0x8(%rbp)
//    0x0000000000001202 <+25>:    xor    %eax,%eax

// 132         int a;
// 133         std::cin >> a; // 运行时输入，编译器无法推导值
//    0x0000000000001204 <+27>:    lea    -0x14(%rbp),%rax
//    0x0000000000001208 <+31>:    mov    %rax,%rsi
//    0x000000000000120b <+34>:    lea    0x2f4e(%rip),%rax        # 0x4160 <_ZSt3cin@GLIBCXX_3.4>
//    0x0000000000001212 <+41>:    mov    %rax,%rdi
//    0x0000000000001215 <+44>:    call   0x10a0 <_ZNSirsERi@plt>

// 134         int &ra = a;
//    0x000000000000121a <+49>:    lea    -0x14(%rbp),%rax
//    0x000000000000121e <+53>:    mov    %rax,-0x10(%rbp)

// --Type <RET> for more, q to quit, c to continue without paging--ret
// 135         ra = 3;
//    0x0000000000001222 <+57>:    mov    -0x10(%rbp),%rax
//    0x0000000000001226 <+61>:    movl   $0x3,(%rax)

// 136         std::cout << a << std::endl;
//    0x000000000000122c <+67>:    mov    -0x14(%rbp),%eax
//    0x000000000000122f <+70>:    mov    %eax,%esi
//    0x0000000000001231 <+72>:    lea    0x2e08(%rip),%rax        # 0x4040 <_ZSt4cout@GLIBCXX_3.4>
//    0x0000000000001238 <+79>:    mov    %rax,%rdi
//    0x000000000000123b <+82>:    call   0x10f0 <_ZNSolsEi@plt>
//    0x0000000000001240 <+87>:    mov    0x2d89(%rip),%rdx        # 0x3fd0
//    0x0000000000001247 <+94>:    mov    %rdx,%rsi
//    0x000000000000124a <+97>:    mov    %rax,%rdi
//    0x000000000000124d <+100>:   call   0x10c0 <_ZNSolsEPFRSoS_E@plt>

// 137     }
//    0x0000000000001252 <+105>:   mov    $0x0,%eax
//    0x0000000000001257 <+110>:   mov    -0x8(%rbp),%rdx
//    0x000000000000125b <+114>:   sub    %fs:0x28,%rdx
//    0x0000000000001264 <+123>:   je     0x126b <main()+130>
//    0x0000000000001266 <+125>:   call   0x10d0 <__stack_chk_fail@plt>
//    0x000000000000126b <+130>:   leave  
// --Type <RET> for more, q to quit, c to continue without paging--


// rbp-0x10 这 8 字节空间是编译器为引用ra专门分配的，
// 存储的是a的地址 —— 这和 “指针变量存储目标地址” 的逻辑完全一致，也是 “引用占内存” 最直接的物理证据。

// 场景	            编译器能否优化引用内存	    原因
// a是编译期常量	能（O2 下完全消除）	        编译器可推导a的最终值，无需存储a和ra，直接传常量给cout
// a是运行时输入	不能（即使 O2 也占内存）	a的值由用户运行时输入，编译器无法提前推导，必须保留a的栈存储；ra作为a的别名，必须存储a的地址，才能在ra=3时找到a的位置


// 意思是引用 本身不是解决少占用空间的问题 而是为了解决写代码写起来更顺畅，读起来更直观吗？ 
// 其实用指针也能达成效果，只不过引用在上次套了一层编译器的约束，怕自己用指针出错，就跟智能指针一样，出现就是为了解决指针的问题


// 你的理解完全精准！可以说这是对引用设计初衷最核心、最到位的总结，我们再把这个逻辑拆得更透，同时厘清引用和智能指针的异同（避免混淆）：
// 一、先敲实核心结论：引用的设计目标从来不是 “省空间”

// 你之前通过汇编已经看到：引用底层和指针占用完全相同的内存（64 位 8 字节），
// 甚至在 - O0 下比直接写指针多了 “编译器自动生成的取地址 / 解引用指令”（但运行时性能完全一致）。

//引用的核心价值，就是在 “不损失指针效率” 的前提下，给程序员套一层 “编译器级别的语法约束”，让代码：
// 写起来更顺：不用手动写&（取地址）、*（解引用），符合 “操作变量本身” 的直觉；
// 读起来更直观：看到int& a就知道 “这是某个变量的别名，操作它就是操作原变量”，而int* a需要先判断 “这是地址，可能为空、可能指向其他地方”；
// 出错更早：所有约束（必须初始化、不可空、不可改指向）都是编译期检查，而指针的空指针、野指针问题要到运行时才暴露，甚至上线后才崩。

// 举个通俗的例子：
// 裸指针 = 一辆 “无安全带、无刹车、无导航” 的手动挡车，能开但极易出事故；
// 引用 = 给这辆车加了 “强制安全带（必须初始化）+ 锁死方向盘（不能改指向）+ 自动挂挡（隐式解引用）”，操作更安全、更顺手，且不影响车速；
// 智能指针 = 给这辆车加了 “自动刹车（超出作用域自动释放）+ 防追尾（引用计数避免重复释放）”，解决的是 “停车忘拉手刹（内存泄漏）” 的问题。

// 三、补充：为什么说 “引用是零成本抽象的典范”
// C++ 设计的核心原则之一是 “不付出不必要的代价”：
// 如果你用引用，编译器只是帮你自动生成 “取地址→解引用” 的指令（和你手写指针的指令完全一样），没有任何额外的运行时开销；
// 这些 “语法约束” 只在编译期生效，编译后的二进制文件和手写指针的版本几乎没有区别（你之前的汇编已经验证了这一点）。
// 这和智能指针不同：shared_ptr 为了实现线程安全的引用计数，会有微小的原子操作开销 —— 但这是为了解决 “内存管理” 这个更大的痛点，属于 “可接受的代价”。
// 最终总结

// “引用不占空间、指针占空间” 是胡扯级的简化结论：
// 从物理实现（运行时）：引用和指针占相同的内存，你的汇编就是最直接的证据；
// 从语法抽象（逻辑层）：引用是别名、指针是对象 —— 但这是 “语义定义”，不是 “内存事实”；
// 从优化场景：二者都可能被编译器优化掉内存，不是引用的专属特性。

//网上可能是因为新手不关注底层，让新手更好的理解引用的功能 就说成别名 然后不占空间 这么说能让新手更好的理解 而不绕来绕去

// 你的判断完全正确—— 引用传参和指针传参的汇编代码几乎一模一样，二者都会占用栈 / 寄存器空间（本质都是传递地址），
// 所谓 “引用传参更省空间” 是和 “值传参” 对比的误读，而非和指针传参的差异。













//引用必须初始化、赋值不能修改、一个变量可以有多个引用









//常引用
// 134         const int &ra = a;
//    0x00000000000011e4 <+27>:    lea    -0x14(%rbp),%rax
//    0x00000000000011e8 <+31>:    mov    %rax,-0x10(%rbp)

// 常引用的const是编译期语法约束（禁止修改绑定的变量），不是 “内存层面的特殊处理”；
// 汇编层面，常引用和普通引用的内存占用、指令逻辑完全一致 —— 都是存储目标变量的地址，占 8 字节（64 位）；
// 唯一区别：试图给常引用赋值（cra=2）会直接编译报错，而普通引用可以赋值（底层是解引用操作），但这是编译期拦截，和运行时内存 / 性能无关。

//const int& cr = 10; // 常引用绑定常量
// const int& cr2 = 1+2; // 常引用绑定临时对象
// 如果是这样  绑定的临时变量地址 那什么时候这个地址失效? 是不是相当于其实已经不是临时变量了
//如果是这种的话 绑定的还是临时变量的地址 只是生命周期延长了 当const引用的生命周期结束时，就失效

// void test() {
//     // 步骤1：创建临时变量（值10，匿名，栈上分配）
//     // 步骤2：const引用cr绑定这个临时变量，临时变量生命周期延长至cr销毁
//     const int& cr = 10;  
    
//     // 此时访问cr的地址（&cr），指向栈上的临时变量，有效
//     cout << &cr << endl; // 输出临时变量的栈地址，有效
// } // 步骤3：test函数结束，局部变量cr销毁 → 绑定的临时变量也销毁 → 该地址失效

// // 离开test函数后，再访问刚才的&cr地址 → 栈空间已被回收，属于野指针，未定义行为

// // 全局const引用，生命周期贯穿整个程序
// const int& g_cr = 1+2; 

// int main() {
//     cout << &g_cr << endl; // 临时变量（值3）的地址，全程有效
//     return 0;
// } 
// // 程序退出时，全局引用g_cr销毁 → 临时变量销毁 → 地址失效


// 不管是普通引用int& ra = a，还是常引用const int& cr = 10，编译器都会在栈上分配一块内存（64 位 8 字节），存储目标变量 / 临时变量的地址；
// 简单说：编译器处理引用时，就是把它当成 “被阉割了部分功能的指针变量” 来实现的—— 阉割的功能包括 “改指向、存空值、显式取自身地址” 等。

// const 引用（const T&）	语法约束：禁止通过该引用修改绑定的对象；底层是存地址的指针（栈 / 寄存器）	引用自身（指针）：栈 / 寄存器；绑定的对象：看对象类型
// 只读数据段（.rodata）	程序的内存分区之一，存储编译期确定的、不可修改的常量（如全局 const 变量、字符串字面量）	进程的只读内存区域（修改会触发段错误）


//const int& a 修改报错是编译期的语法约束（编译器直接拦截），和底层汇编无关；而 “只读” 要分「语法层只读」和「物理层只读」—— 前者靠编译器拦截，后者靠操作系统内存权限拦截，二者完全独立。


// 为什么底层汇编一致，但const int& a修改会报错？
// 关键在于：const的约束发生在 “编译早期”，远早于生成汇编的阶段，
// 汇编一致的前提是 “不触发修改操作”（比如仅读取）；如果尝试修改const int&，编译器根本不会生成对应的汇编，直接报错。

// 预处理 → 语法/语义分析 → 中间代码生成 → 汇编生成 → 链接

// 维度	           本质	               表现特征	                                    判断方法	                                                                    典型场景
// 语法层只读	编译器拦截修改	        尝试修改 →  编译报错                    写修改代码，看是否编译通过	                                                const T&、局部const T变量
// 物理层只读	操作系统内存权限拦截	尝试修改 →  编译通过，但运行段错误	1. 强制修改（const_cast）看是否崩；2. 用objdump看内存分区               全局const T变量、字符串字面量（.rodata段



// #include <iostream>
// const int j = 1;
// int main() {
//     const int c = 10;
//     int a;
//     std::cin >> a; // 运行时输入，编译器无法推导值
//     int &ra = a;
//     ra = 3;
//     std::cout << a << std::endl;
// }
// msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ objdump -t test | grep "j" //查看是否在只读数据段
// 0000000000002004 l     O .rodata        0000000000000004              _ZL1j
// msy@msy-virtual-machine:~/Cpp-Knowledge-Notes$ 
//.rodata 虚拟内存的只读段












