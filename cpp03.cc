/*
引用作返回值情况
*/

#include <iostream>

int& fun(){
    int n = 2;
    std::cout<<&n<<std::endl;
    return &n;
}
int main(){
    int a= fun();
    std::cout<<a<<std::endl;
    std::cout<<&a<<std::endl;
    return 0;

    //这段代码 编译的时候会警告,但是可以编译成功，然后运行会触发核心转储 
    //然后我们开始调试 这里再展示以下调试技巧

    //gdb ./test
    //bt 查看调用栈 -> bt full 查看完整调用栈
    //frame 切换栈
    // info locals 查看局部变量
    // print 查看指定变量值
    //disassemble 查看汇编源码
    //info registers 出现：14            0x555555557d78      93824992247160
// r15            0x7ffff7ffd040      140737354125376
// rip            0x55555555526e      0x55555555526e <main()+32>
// eflags         0x10246             [ PF ZF IF RF ]
// cs             0x33                51
    //代表是地址0x5526e这里出的错

//     (gdb) disassemble /m fun
// Dump of assembler code for function _Z3funv:
// 7       int& fun(){
//    0x00005555555551e9 <+0>:     endbr64 
//    0x00005555555551ed <+4>:     push   %rbp
//    0x00005555555551ee <+5>:     mov    %rsp,%rbp
//    0x00005555555551f1 <+8>:     sub    $0x10,%rsp
//    0x00005555555551f5 <+12>:    mov    %fs:0x28,%rax
//    0x00005555555551fe <+21>:    mov    %rax,-0x8(%rbp)
//    0x0000555555555202 <+25>:    xor    %eax,%eax

// 8           int n = 2;
//    0x0000555555555204 <+27>:    movl   $0x2,-0xc(%rbp)

// 9           std::cout<<&n<<std::endl;
//    0x000055555555520b <+34>:    lea    -0xc(%rbp),%rax
//    0x000055555555520f <+38>:    mov    %rax,%rsi
//    0x0000555555555212 <+41>:    lea    0x2e27(%rip),%rax        # 0x555555558040 <_ZSt4cout@GLIBCXX_3.4>
//    0x0000555555555219 <+48>:    mov    %rax,%rdi
//    0x000055555555521c <+51>:    call   0x5555555550a0 <_ZNSolsEPKv@plt>
//    0x0000555555555221 <+56>:    mov    0x2da8(%rip),%rdx        # 0x555555557fd0
//    0x0000555555555228 <+63>:    mov    %rdx,%rsi
//    0x000055555555522b <+66>:    mov    %rax,%rdi
//    0x000055555555522e <+69>:    call   0x5555555550c0 <_ZNSolsEPFRSoS_E@plt>

// 10          return n;
//    0x0000555555555233 <+74>:    mov    $0x0,%eax //这里错误了 0x0
// 致命错误：
// 1. 函数声明是int&（返回引用），编译器应把n的地址（RBP-0xC）存入 RAX（64 位返回指针 / 引用的寄存器）；
// 2. 但这里却把 EAX 设为0 → 相当于返回了空指针的引用；
// 3. 即使源码写return &n，也会返回即将销毁的栈地址（仍错误）

// 11      }
//    0x0000555555555238 <+79>:    mov    -0x8(%rbp),%rdx
//    0x000055555555523c <+83>:    sub    %fs:0x28,%rdx
// --Type <RET> for more, q to quit, c to continue without paging--
//    0x0000555555555245 <+92>:    je     0x55555555524c <_Z3funv+99>
//    0x0000555555555247 <+94>:    call   0x5555555550d0 <__stack_chk_fail@plt>
//    0x000055555555524c <+99>:    leave  
//    0x000055555555524d <+100>:   ret    




// # main中调用fun()的关键汇编
// callq  0x5555555551e9 <fun()>  # 调用fun()，返回后RAX=0（空地址）
// mov    %rax,%edi                # RDI = RAX = 0（把fun()返回的"引用地址"存入RDI）
// mov    (%edi),%eax              # 致命：访问RDI指向的地址（0）→ 空指针解引用


// mov (%edi),%eax 试图读取地址0的值 → 触发 SIGSEGV 信号（段错误），操作系统生成 Core Dump；
// 即使编译器没把 RAX 设为 0（比如你改源码为return &n），ret返回后n的栈地址已被释放，mov (%edi),%eax 访问的是无效栈内存 → 仍会崩溃（未定义行为）。

// main() 中mov (%edi),%eax（访问fun()返回的无效地址）是直接触发 Core Dump 的汇编指令；

// 永远不要返回局部变量的引用 / 指针 —— 栈帧销毁后，对应的内存地址会失效，访问即触发段错误。



//这里我写错了 ，应该是返回n的地址 我写的返回n本身 所以写入寄存器的值是0X0 我再修改 然后测试下
// int& fun(){
    // int n = 2;
    // std::cout<<&n<<std::endl;
    // return &n;
// }
//直接编译不通过了
// }
//靠，脑子乱了，没写错 如果是引用返回的话 不用带& 本身是为了简化指针存在的引用
//所以不用带& 怪不得编译错误 我的锅
// 写 return global_n 时：
// 编译器自动将 int 类型的 global_n 转换为「它的引用」（int&），本质是取 global_n 的地址作为引用的目标；
// 写 return &global_n 时：
// 编译器自动将 int* 类型的 &global_n（地址）转换为「int& 引用」（地址的别名），本质是把指针指向的地址绑定到引用上。
// int global_n = 10;
// int& fun() {
    // return &global_n;  // 显式取地址，编译器自动转为引用
// }
// 虽然两种写法等价，但优先推荐 return global_n
// 之前的错误代码（返回局部变量 n 的引用）中，无论写 return n 还是 return &n，都是错误的 —— 核心问题不是 “加不加 &”，
// 而是「局部变量的生命周期」：



// 返回引用（如 int& fun()）的本质是：返回一个变量的「内存地址的别名」 —— 不是返回变量的值（拷贝），
// 而是返回变量本身的 “间接引用”，调用者可以通过这个引用直接操作原变量的内存。



//返回引用返回的是这个变量的地址 ，拷贝也只拷贝一个地址 8/16字节 开销小
//调用者可以通过引用修改原变量



//而普通的int fun()返回返回的是结果的整个拷贝，调用者操作的也是拷贝，不影响原变量
//这里拷贝是整个变量 可能涉及两份内存 两个地址 而引用是两个地址指向一份内存
//类似于浅拷贝 深拷贝

    // 引用做返回值的接收方式：
    // 1.引用接收
    //  int& ref = fun();  // 引用类型接收：ref绑定global_n的地址
    //  ref = 20;          // 直接修改原变量global_n
    //  cout << global_n;  // 输出20（原变量被修改）
    // 2.普通接收
    // int main() {
    // int a = fun();      // 普通变量接收：拷贝global_n的值到a
    // a = 30;             // 修改a，不影响原变量
    // cout << global_n;   // 输出20（原变量未变）
    // cout << a;          // 输出30（a是独立拷贝）
    // return 0;
    // }
    //3.常引用接收
    //     int main() {
    //     const int& const_ref = fun();  // const引用接收：绑定地址，只读
    //     // const_ref = 40;            // 编译错误！const引用不可修改
    //     cout << const_ref;             // 输出20（读取原变量值）
    //     cout << global_n;              // 输出20（原变量未变）
    //     return 0;
    // }







//引用 占用的空间是栈上的，随栈释放，不是堆的
// 引用在语义上不占独立内存（C++ 标准规定），但在大部分实际场景中，编译器会用指针实现引用（占 8 字节 / 64 位）；只有当编译器能优化掉指针实现时，引用才真的不占空间。
// 对于开发者来说，不用纠结 “占不占空间”—— 按标准语义使用引用即可：
// 把引用当 “别名”，关注「绑定对象的生命周期」（避免悬空引用）；
// 不用手动管理引用的内存（无需delete引用）；
// 类成员引用、函数参数引用会间接占用空间（如类大小增加 8 字节），但这是实现细节，不影响代码逻辑。
// 简单说：“引用不占空间” 是 C++ 的语义设计，“引用占 8 字节” 是编译器的实现妥协，两者都对，只是讨论的层面不同。


//如果在00级别下 引用一定占空间 编译器无法优化

// 如果02级别 像const int & a= 10; 或者int a = 10,const int &b =a,这种编译器能推导出来引用的结果的 
// 就直接优化了 变相的不占内存